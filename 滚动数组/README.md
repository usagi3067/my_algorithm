## 滚动数组
常运用于动态规划的空间优化中。

因为DP题目是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。

 直接看以下例子。 

```c++
int i, j, d[100][100];
for(i = 1; i < 100; i++)
    for(j = 0; j < 100; j++)
        d[i][j] = d[i - 1][j] + d[i][j - 1];
```

因为d\[i]\[j]只依赖于d\[i - 1]\[j]和d\[i]\[j - 1]。

运用滚动数组，可优化为：

```c++
int i, j, d[2][100];
for(i = 1; i < 100; i++)
    for(j = 0; j < 100; j++)
        d[i % 2][j] = d[(i - 1) % 2][j] + d[i % 2][j - 1];
```



进阶版优化：

可以直接优化成一维形式， 空间再缩小一倍。

直接在当前行做修改。 分以下情况

a. 若d\[i]\[j] 只依赖于**上一行靠右列（包括第j列）的元素**或**当前行靠左列的元素**

如： 

```c++
int i, j, d[100][100];
for(i = 1; i < 100; i++)
    for(j = 0; j < 100; j++)
        d[i][j] = d[i - 1][j] + d[i][j - 1];
```

可直接优化为：

```c++
int i, j, d[100];
for (i = 1; i < 100; i ++)
	for(j = 0; j < 100; j ++)   //从前往后遍历
    	d[j] = d[j] + d[j - 1]
```

b. 若d\[i]\[j] 只依赖于**上一行靠左列（包括第j列）的元素**或**当前行靠右列的元素**

如： 

```c++
int i, j, d[100][100];
for(i = 1; i < 100; i++)
    for(j = 0; j < 100; j++)
        d[i][j] = d[i - 1][j] + d[i][j + 1];
```

可直接优化为：

```c++
int i, j, d[100];
for(i = 1; i < 100; i++)
    for(j = 100 - 1; j >= 0; j--)  //从后往前遍历
        d[i][j] = d[i - 1][j] + d[i][j + 1];
```

